// src/scraper.ts
import dotenv from "dotenv";
dotenv.config();

import { chromium, BrowserContext, Browser } from "playwright";
import fs from "fs";
import path from "path";
import http from "http";
import https from "https";
import { franc } from "franc";

const API_DELAY_MS = Number(process.env.API_DELAY_MS || 900);
const MAX_CONCURRENCY = Number(process.env.MAX_CONCURRENCY || 2);
const MAX_VIDEOS_PER_PROFILE = Number(process.env.MAX_VIDEOS_PER_PROFILE || 6);
const HEADLESS = process.env.HEADLESS === "true";

const FOLLOWERS_MIN = 10_000;
const FOLLOWERS_MAX = 80_000;

const BACKEND_BASE = (process.env.BACKEND_BASE || "https://tiktokfinder.onrender.com").replace(/\/$/, "");

const USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.6 Safari/605.1.15",
];

function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}
function parseCount(txt: string | number | undefined | null): number {
  if (txt === undefined || txt === null) return 0;
  let s = String(txt).replace(/\s+/g, "").replace(/\u00A0/g, "");
  const m = s.match(/^([\d,.]+)([KMkmB])?$/);
  if (!m) {
    const plain = s.replace(/[^\d]/g, "");
    const n = Number(plain);
    return isNaN(n) ? 0 : n;
  }
  let num = parseFloat(m[1].replace(/,/g, ""));
  const suf = (m[2] || "").toUpperCase();
  if (suf === "K") return Math.round(num * 1_000);
  if (suf === "M") return Math.round(num * 1_000_000);
  if (suf === "B") return Math.round(num * 1_000_000_000);
  return Math.round(num);
}

// ---------- avatar helpers ----------
function cleanAvatarUrlKeepQuery(raw: string | null | undefined): string | null {
  if (!raw) return null;
  let u = String(raw).replace(/&amp;/g, "&").trim();
  try { u = decodeURIComponent(u); } catch (e) { /* ignore */ }
  if (!u.startsWith("http")) return null;
  return u;
}
function sanitizeKeepDot(handle: string) {
  return String(handle).trim().replace(/[^a-zA-Z0-9._-]/g, "_");
}

/**
 * Download avatar and save as exactly <handle>.jpeg
 * return '/avatars/<handle>.jpeg' or null on failure
 */
async function downloadAndCacheAvatar(context: BrowserContext, avatarUrl: string, handle: string): Promise<string | null> {
  try {
    const avatarsDir = path.join(process.cwd(), "public", "avatars");
    if (!fs.existsSync(avatarsDir)) fs.mkdirSync(avatarsDir, { recursive: true });

    const filename = `${sanitizeKeepDot(handle)}.jpeg`;
    const filepath = path.join(avatarsDir, filename);

    if (fs.existsSync(filepath)) return `/avatars/${filename}`;

    let buffer: Buffer | null = null;
    try {
      // @ts-ignore - Playwright request context
      if ((context as any).request && typeof (context as any).request.get === "function") {
        const resp = await (context as any).request.get(avatarUrl, { timeout: 30000 });
        if (resp && resp.ok && resp.ok()) {
          buffer = await resp.body();
        }
      }
    } catch (e) {
      buffer = null;
    }

    if (!buffer) {
      // fallback to node http/https
      buffer = await new Promise<Buffer>((resolve, reject) => {
        const client = avatarUrl.startsWith("https") ? https : http;
        const req = client.get(avatarUrl.replace(/&amp;/g, "&"), (res) => {
          if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 300)) {
            res.resume();
            return reject(new Error(`avatar download failed status ${res.statusCode}`));
          }
          const chunks: Buffer[] = [];
          res.on("data", (c) => chunks.push(Buffer.from(c)));
          res.on("end", () => resolve(Buffer.concat(chunks)));
        });
        req.on("error", (err) => reject(err));
        req.setTimeout(20000, () => {
          req.abort();
          reject(new Error("avatar download timeout"));
        });
      });
    }

    fs.writeFileSync(filepath, buffer);
    return `/avatars/${filename}`;
  } catch (err) {
    console.warn("[avatar] error downloading avatar:", err);
    return null;
  }
}

// ---------- seed writer (unchanged) ----------
const SEED_PATH = path.join(process.cwd(), "prisma", "seed.ts");
if (!fs.existsSync(SEED_PATH)) {
  fs.writeFileSync(SEED_PATH, `// Auto-generated by scraper\nexport const influencers = [\n`, "utf8");
}
function appendToSeed(obj: any) {
  const line = "  " + JSON.stringify(obj, (_k, v) => (v === undefined ? null : v), 2) + ",\n";
  fs.appendFileSync(SEED_PATH, line, "utf8");
}
function finalizeSeedFile() {
  fs.appendFileSync(SEED_PATH, `];\n`, "utf8");
}

// ---------- SIGI_STATE helper ----------
function extractSigiState(html: string): any | null {
  const reIdScript = /<script[^>]*id=["']SIGI_STATE["'][^>]*>([\s\S]*?)<\/script>/i;
  let m = html.match(reIdScript);
  if (m) {
    try { return JSON.parse(m[1]); } catch {}
  }
  const reWindow = /window\[['"]SIGI_STATE['"]\]\s*=\s*({[\s\S]*?});/;
  m = html.match(reWindow);
  if (m) {
    try { return JSON.parse(m[1]); } catch {}
  }
  return null;
}

// ---------- video stats & pinned detection ----------
function extractVideoStatsFromHtml(html: string) {
  let play = 0, like = 0, comment = 0, share = 0, followers = 0;
  const statsRegex = /"stats"\s*:\s*({[\s\S]*?})/;
  const sMatch = html.match(statsRegex);
  if (sMatch) {
    try {
      const statsObj = JSON.parse(sMatch[1]);
      play = parseCount(statsObj.playCount ?? statsObj.play_count ?? statsObj.plays ?? 0);
      like = parseCount(statsObj.diggCount ?? statsObj.digg_count ?? statsObj.likeCount ?? 0);
      comment = parseCount(statsObj.commentCount ?? statsObj.comment_count ?? 0);
      share = parseCount(statsObj.shareCount ?? statsObj.share_count ?? 0);
    } catch {}
  }
  const authRegex = /"authorStats"\s*:\s*({[\s\S]*?})/;
  const aMatch = html.match(authRegex);
  if (aMatch) {
    try {
      const aobj = JSON.parse(aMatch[1]);
      followers = parseCount(aobj.followerCount ?? aobj.follower_count ?? aobj.followers ?? 0);
    } catch {}
  }
  if (!play) {
    const p = html.match(/"playCount"\s*:\s*([0-9,.KMkm]+)/);
    if (p) play = parseCount(p[1]);
  }
  if (!like) {
    const l = html.match(/"diggCount"\s*:\s*([0-9,.KMkm]+)/) || html.match(/"likeCount"\s*:\s*([0-9,.KMkm]+)/);
    if (l) like = parseCount(l[1]);
  }
  if (!comment) {
    const c = html.match(/"commentCount"\s*:\s*([0-9,.KMkm]+)/);
    if (c) comment = parseCount(c[1]);
  }
  if (!share) {
    const s = html.match(/"shareCount"\s*:\s*([0-9,.KMkm]+)/);
    if (s) share = parseCount(s[1]);
  }
  if (!play) {
    const tv = html.replace(/\s+/g, " ").match(/([0-9,.KMkm]+)\s*views/i);
    if (tv) play = parseCount(tv[1]);
  }
  if (!like) {
    const tl = html.replace(/\s+/g, " ").match(/([0-9,.KMkm]+)\s*likes/i);
    if (tl) like = parseCount(tl[1]);
  }
  return { play, like, comment, share, followers };
}
function getPinnedIdsFromProfileHtml(html: string): Set<string> {
  const pinned = new Set<string>();
  const badgeRe = /<div[^>]*data-e2e=["']video-card-badge["'][^>]*>([\s\S]*?)<\/div>/gi;
  let bm;
  while ((bm = badgeRe.exec(html)) !== null) {
    const idx = bm.index;
    const start = Math.max(0, idx - 1500);
    const end = Math.min(html.length, idx + 1500);
    const window = html.slice(start, end);
    const anchorMatch = window.match(/\/@[\w.-]+\/video\/(\d+)/i);
    if (anchorMatch) pinned.add(anchorMatch[1]);
    else {
      const idMatch = window.match(/"id"\s*:\s*"?(\d{6,})"?/);
      if (idMatch) pinned.add(idMatch[1]);
    }
  }
  const anchorWithPinnedRe = /\/@[\w.-]+\/video\/(\d+)[\s\S]{0,200}?<div[^>]*data-e2e=["']video-card-badge["'][^>]*>[\s\S]*?Pinned/i;
  let am;
  while ((am = anchorWithPinnedRe.exec(html)) !== null) {
    pinned.add(am[1]);
  }
  const enableRe = /"enable_profile_pinned_video"\s*:\s*\{([\s\S]*?)\}/i;
  const eMatch = html.match(enableRe);
  if (eMatch) {
    const area = eMatch[1];
    const numIds = area.match(/\d{6,}/g);
    if (numIds) numIds.forEach((id) => pinned.add(id));
    const objEnd = eMatch.index ?? 0;
    const after = html.slice((objEnd + eMatch[0].length), (objEnd + eMatch[0].length + 500));
    const afterIds = after.match(/\d{6,}/g);
    if (afterIds) afterIds.forEach((id) => pinned.add(id));
  }
  return pinned;
}

// ---------- browser helpers (non-persistent) ----------
async function openContext(): Promise<{ browser: Browser; context: BrowserContext }> {
  const browser = await chromium.launch({ headless: HEADLESS });
  const context = await browser.newContext({
    userAgent: USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)],
  });
  await context.route("**/*", (route) => {
    const url = route.request().url();
    const block = [".css", "google-analytics", "analytics", "font", "doubleclick"];
    if (block.some((b) => url.includes(b))) route.abort();
    else route.continue();
  });
  return { browser, context };
}

// ---------- improved handle extraction from hashtag (scroll + DOM) ----------
async function getHandlesFromHashtag(page: any, hashtag: string, maxHandles = 80) {
  const url = `https://www.tiktok.com/tag/${encodeURIComponent(hashtag)}`;
  await page.goto(url, { timeout: 60000 });
  await page.waitForTimeout(3000);

  const captcha = await page.$("iframe[src*='captcha'], .captcha-container");
  if (captcha) {
    console.log("⚠️ Captcha detectado. Resuélvelo manualmente.");
    await page.waitForFunction(() => !document.querySelector("iframe[src*='captcha'], .captcha-container"), { timeout: 0 });
    console.log("✅ Captcha resuelto, continuando...");
  }

  const handlesSet = new Set<string>();

  // helper to extract from DOM (faster and more reliable than regex on HTML)
  const extractFromDom = async () => {
    try {
      const hrefs: string[] = await page.evaluate(() => {
        const anchors = Array.from(document.querySelectorAll('a[href]'));
        return anchors.map(a => (a as HTMLAnchorElement).href);
      });
      for (const href of hrefs) {
        const m = href.match(/\/@([\w.-]+)/);
        if (m) handlesSet.add(m[1]);
        if (handlesSet.size >= maxHandles) break;
      }
    } catch (e) {
      // ignore
    }
  };

  // initial extraction
  await extractFromDom();

  // scroll & extract until we reach maxHandles or maxScrolls
  const MAX_SCROLLS = 10;
  let scrolls = 0;
  while (handlesSet.size < maxHandles && scrolls < MAX_SCROLLS) {
    scrolls++;
    try {
      await page.evaluate(() => {
        window.scrollBy(0, window.innerHeight * 1.5);
      });
    } catch (e) { /* ignore */ }
    await page.waitForTimeout(1200 + Math.floor(Math.random() * 1200));
    await extractFromDom();
  }

  console.log(`Found ${handlesSet.size} handles for hashtag ${hashtag} (scrolled ${scrolls} times)`);
  return Array.from(handlesSet);
}

// ---------- scrapeProfile ----------
async function scrapeProfile(context: BrowserContext, handle: string, niche?: string) {
  const page = await context.newPage();
  try {
    const url = `https://www.tiktok.com/@${handle}`;
    await page.goto(url, { waitUntil: "domcontentloaded", timeout: 40000 });
    await page.waitForTimeout(3000);

    let html = await page.content();
    const sigi = extractSigiState(html);

    // ---- user fields ----
    let followers = 0;
    let avatarUrl: string | null = null;
    let bio = "";

    // SIGI_STATE extraction (prefer)
    if (sigi && sigi.UserModule) {
      const usersObj = sigi.UserModule.users || sigi.UserModule;
      if (usersObj && typeof usersObj === "object") {
        const tryKeys = [handle, handle.toLowerCase(), handle.replace(/^@/, "")];
        for (const k of tryKeys) {
          if (usersObj[k]) {
            const u = usersObj[k];
            followers = Number(u.followerCount ?? u.follower_count ?? followers) || followers;
            const cand = u.avatarLarger || u.avatar || u.avatar_medium || u.avatarThumb || null;
            if (cand) avatarUrl = cleanAvatarUrlKeepQuery(cand);
            bio = (u.signature ?? u.description ?? bio) || "";
            break;
          }
        }
        if (!avatarUrl) {
          for (const key of Object.keys(usersObj)) {
            const u = usersObj[key];
            if (!u) continue;
            const possibleNames = [
              u.uniqueId, u.uniqueId?.toLowerCase?.(), u.shortId, u.nickName, u.nickname, u.nickname?.toLowerCase?.(),
            ].filter(Boolean).map(String);
            if (possibleNames.includes(handle) || possibleNames.includes(handle.replace(/^_/, ""))) {
              followers = Number(u.followerCount ?? u.follower_count ?? followers) || followers;
              const cand = u.avatarLarger || u.avatar || u.avatar_medium || u.avatarThumb || null;
              if (cand) avatarUrl = cleanAvatarUrlKeepQuery(cand);
              bio = (u.signature ?? u.description ?? bio) || "";
              break;
            }
          }
        }
      }
    }

    // meta og:image fallback
    if (!avatarUrl) {
      const metaImg = html.match(/<meta[^>]*property=["']og:image["'][^>]*content=["']([^"']+)["']/i);
      if (metaImg) avatarUrl = cleanAvatarUrlKeepQuery(metaImg[1]);
    }

    // broad tiktokcdn search fallback
    if (!avatarUrl) {
      const urlRegex = /https?:\/\/[^\s"'<>]*?(?:tiktokcdn\.com|tiktokv\.com)[^\s"'<>]*?\.(?:jpe?g|png|avif|webp)(?:[^\s"'<>]*)/gi;
      const found = html.match(urlRegex);
      if (found && found.length > 0) {
        const prefer = found.find((u) => /avt|avatar|avatarLarger|avatar_thumb|avatar_medium|cropcenter/i.test(u));
        avatarUrl = cleanAvatarUrlKeepQuery(prefer || found[0]);
      }
    }

    // last resort avatar key
    if (!avatarUrl) {
      const anyAvatarRe = /"avatarLarger"\s*:\s*"(https?:[^"]+)"/i;
      const m = html.match(anyAvatarRe);
      if (m) avatarUrl = cleanAvatarUrlKeepQuery(m[1]);
    }

    // fallback followers
    if (!followers) {
      const fMatch = html.match(/"followerCount"\s*:\s*([0-9,.KMkm]+)/);
      if (fMatch) followers = parseCount(fMatch[1]);
    }
    // fallback bio
    if (!bio) {
      const bioMatch = html.match(/"signature"\s*:\s*"(.*?)"/);
      if (bioMatch) bio = bioMatch[1].replace(/\\"/g, '"');
    }

    // immediate follower filter
    if (!(FOLLOWERS_MIN <= followers && followers <= FOLLOWERS_MAX)) {
      console.log(`[${handle}] ❌ Skip (followers=${followers})`);
      await page.close();
      return null;
    }

    // download avatar and return absolute URL when possible
    let finalAvatarUrl: string | null = null;
    if (avatarUrl) {
      const downloaded = await downloadAndCacheAvatar(context, avatarUrl, handle);
      if (downloaded) {
        finalAvatarUrl = `${BACKEND_BASE}${downloaded}`;
        console.log(`[${handle}] avatar cached -> ${finalAvatarUrl}`);
      } else {
        finalAvatarUrl = avatarUrl;
        console.log(`[${handle}] avatar download failed; keeping remote URL -> ${avatarUrl}`);
      }
    } else {
      console.log(`[${handle}] avatar NOT found`);
    }

    // pinned detection and video collection
    const pinnedIds = getPinnedIdsFromProfileHtml(html);
    if (pinnedIds.size > 0) console.log(`[${handle}] pinnedIds detected:`, Array.from(pinnedIds));

    const collected = new Set<string>();
    const collectFromHtml = (h: string) => {
      const anchorRegex = /\/@[\w.-]+\/video\/(\d+)/g;
      let aMatch;
      while ((aMatch = anchorRegex.exec(h)) !== null && collected.size < MAX_VIDEOS_PER_PROFILE * 3) {
        const id = aMatch[1];
        if (!pinnedIds.has(id)) collected.add(id);
      }
    };
    collectFromHtml(html);

    const MAX_SCROLLS = 8;
    let scrolls = 0;
    while (collected.size < MAX_VIDEOS_PER_PROFILE && scrolls < MAX_SCROLLS) {
      scrolls++;
      try { await page.evaluate(() => window.scrollBy(0, window.innerHeight * 1.3)); } catch {}
      await page.waitForTimeout(1400 + Math.floor(Math.random() * 1000));
      html = await page.content();
      const morePinned = getPinnedIdsFromProfileHtml(html);
      morePinned.forEach((id) => pinnedIds.add(id));
      collectFromHtml(html);
    }

    let videoIds = Array.from(collected).filter((id) => !pinnedIds.has(id)).slice(0, MAX_VIDEOS_PER_PROFILE);
    console.log(`[${handle}] videoIds found (non-pinned):`, videoIds);

    if (videoIds.length === 0) {
      await page.close();
      return {
        handle,
        profileUrl: url,
        followers,
        avatarUrl: finalAvatarUrl || null,
        niche: niche || null,
        avgViews: 0,
        engagementRate: 0,
        bio,
        language: bio ? (typeof franc === "function" ? franc(bio) : "und") : "und",
        lastScrapedAt: new Date().toISOString(),
      };
    }

    // open videos and extract stats; skip pinned pages
    const plays: number[] = [];
    let totalLikes = 0, totalComments = 0, totalShares = 0;
    for (let i = 0; i < Math.min(videoIds.length, MAX_VIDEOS_PER_PROFILE); i++) {
      const vidId = videoIds[i];
      const vidUrl = `https://www.tiktok.com/@${handle}/video/${vidId}`;
      try {
        const vpage = await context.newPage();
        await vpage.goto(vidUrl, { waitUntil: "domcontentloaded", timeout: 35000 });
        await vpage.waitForTimeout(2200 + Math.floor(Math.random() * 800));

        const vhtml = await vpage.content();

        const isPinnedOnPage = /data-e2e=["']video-card-badge["'][^>]*>[\s\S]*?Pinned/i.test(vhtml) ||
          /"is_pinned"\s*:\s*true/i.test(vhtml);
        if (isPinnedOnPage) {
          console.log(`[${handle}] video ${vidId} skipped (page-level pinned).`);
          await vpage.close();
          continue;
        }

        const vsigi = extractSigiState(vhtml);
        let play = 0, like = 0, comment = 0, share = 0, vidFollowers = 0;

        if (vsigi && vsigi.ItemModule && vsigi.ItemModule[vidId]) {
          const it = vsigi.ItemModule[vidId];
          play = parseCount(it.stats?.playCount ?? it.playCount ?? it.play_count ?? it.video?.playCount ?? 0);
          like = parseCount(it.stats?.diggCount ?? it.diggCount ?? it.stats?.likeCount ?? 0);
          comment = parseCount(it.stats?.commentCount ?? it.commentCount ?? 0);
          share = parseCount(it.stats?.shareCount ?? it.shareCount ?? 0);
        } else {
          const parsed = extractVideoStatsFromHtml(vhtml);
          play = parsed.play;
          like = parsed.like;
          comment = parsed.comment;
          share = parsed.share;
          vidFollowers = parsed.followers || 0;
        }

        if (vidFollowers && vidFollowers > followers) followers = vidFollowers;
        if (play > 0) plays.push(play);
        totalLikes += like;
        totalComments += comment;
        totalShares += share;

        await vpage.close();
        await sleep(400 + Math.floor(Math.random() * 400));
      } catch (err) {
        console.warn(`[${handle}] video ${vidId} -> error reading:`, err);
        try { const pages = context.pages(); if (pages.length) await pages[pages.length - 1].close(); } catch {}
      }
    }

    // engagement calculation
    let avgViews = 0;
    let engagementRate = 0;
    const nVideos = plays.length;
    if (nVideos > 0) {
      avgViews = Math.round(plays.reduce((a, b) => a + b, 0) / nVideos);
      const totalEng = totalLikes + totalComments + totalShares;
      if (followers > 0) {
        const perPostEng = totalEng / nVideos;
        engagementRate = Number(((perPostEng / followers) * 100).toFixed(2));
      }
    }

    let language = "und";
    try { if (bio && typeof franc === "function") language = franc(bio) || "und"; } catch {}

    await page.close();

    return {
      handle,
      profileUrl: url,
      followers,
      avatarUrl: finalAvatarUrl || null,
      niche: niche || null,
      avgViews,
      engagementRate,
      bio,
      language,
      lastScrapedAt: new Date().toISOString(),
    };
  } catch (err) {
    console.error("❌ Error scraping profile", handle, err);
    try { await page.close(); } catch {}
    return null;
  }
}

// ---------- main pipeline ----------
async function runForHashtags(hashtags: string[]) {
  const { browser, context } = await openContext();
  const page = await context.newPage();

  console.log("⚠️ Si aparece un CAPTCHA, resuélvelo manualmente en la ventana abierta.");
  console.log("Cuando termines, presiona Enter para continuar...");
  await new Promise((resolve) => process.stdin.once("data", resolve));

  const discovered = new Map<string, string>();
  for (const tag of hashtags) {
    console.log("Discovering handles for", tag);
    const handles = await getHandlesFromHashtag(page, tag, 400); // más handles por tag
    handles.forEach((h) => discovered.set(h, tag));
    await sleep(API_DELAY_MS);
  }

  console.log("Total discovered handles:", discovered.size);

  const handlesArr = Array.from(discovered.entries());
  for (let i = 0; i < handlesArr.length; i += MAX_CONCURRENCY) {
    const slice = handlesArr.slice(i, i + MAX_CONCURRENCY);
    for (const [handle, niche] of slice) {
      await sleep(API_DELAY_MS);
      const profile = await scrapeProfile(context, handle, niche);
      if (!profile) continue;
      appendToSeed(profile);
      console.log("✅ Saved:", profile.handle, "followers", profile.followers, "ER", profile.engagementRate + "%", "avatar:", profile.avatarUrl);
    }
  }

  await page.close();
  await context.close();
  await browser.close();
  finalizeSeedFile();
}

// Entry
(async () => {
  const tagsStr = process.env.TAGS || "marketing,fitness,food";
  const tags = tagsStr.split(",").map((t) => t.trim()).filter(Boolean);
  await runForHashtags(tags);
  console.log("🎉 Done. Data appended to prisma/seed.ts");
})();
