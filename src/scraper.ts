// src/scraper.ts
import dotenv from "dotenv";
dotenv.config();

import { chromium, BrowserContext } from "playwright";
import fs from "fs";
import path from "path";
import { franc } from "franc";

const API_DELAY_MS = Number(process.env.API_DELAY_MS || 900);
const MAX_CONCURRENCY = Number(process.env.MAX_CONCURRENCY || 2);
const MAX_VIDEOS_PER_PROFILE = Number(process.env.MAX_VIDEOS_PER_PROFILE || 6);
const HEADLESS = process.env.HEADLESS === "true";

const FOLLOWERS_MIN = 10_000;
const FOLLOWERS_MAX = 80_000;

const USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.6 Safari/605.1.15",
];

function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

function parseCount(txt: string | number | undefined | null): number {
  if (txt === undefined || txt === null) return 0;
  let s = String(txt).replace(/\s+/g, "").replace(/\u00A0/g, "");
  const m = s.match(/^([\d,.]+)([KMkmB])?$/);
  if (!m) {
    const plain = s.replace(/[^\d]/g, "");
    const n = Number(plain);
    return isNaN(n) ? 0 : n;
  }
  let num = parseFloat(m[1].replace(/,/g, ""));
  const suf = (m[2] || "").toUpperCase();
  if (suf === "K") return Math.round(num * 1_000);
  if (suf === "M") return Math.round(num * 1_000_000);
  if (suf === "B") return Math.round(num * 1_000_000_000);
  return Math.round(num);
}

// ---------- avatar helpers ----------
// decode &amp; and keep query string (we need the token)
// return null if not a valid HTTP url
function cleanAvatarUrlKeepQuery(raw: string | null | undefined): string | null {
  if (!raw) return null;
  let u = String(raw).replace(/&amp;/g, "&").trim();
  // Some avatars contain HTML entities; decode common ones
  try { u = decodeURIComponent(u); } catch (e) { /* ignore */ }
  if (!u.startsWith("http")) {
    // try adding protocol if missing (unlikely)
    return null;
  }
  return u;
}

// download avatar using Playwright APIRequestContext (context.request)
// save in public/avatars/<handle>.<ext> and return path like "/avatars/<handle>.<ext>"
// if download fails, return null
async function downloadAndCacheAvatar(context: BrowserContext, avatarUrl: string, handle: string): Promise<string | null> {
  try {
    const avatarsDir = path.join(process.cwd(), "public", "avatars");
    if (!fs.existsSync(avatarsDir)) fs.mkdirSync(avatarsDir, { recursive: true });

    // Try to get extension from url (jpeg, jpg, png, avif)
    const m = avatarUrl.match(/\.([a-zA-Z0-9]{2,5})(?:[?#]|$)/);
    const ext = (m && m[1]) ? m[1].toLowerCase() : "jpg";
    const filename = `${handle.replace(/[^a-z0-9_\-]/gi, "_")}.${ext}`;
    const filepath = path.join(avatarsDir, filename);

    // Use context.request (shares cookies/headers)
    // @ts-ignore - Playwright types may differ, but context.request should exist
    const resp = await (context as any).request.get(avatarUrl, { timeout: 30000 });
    if (!resp || !resp.ok()) {
      console.warn(`[avatar] download failed for ${avatarUrl} status=${resp ? resp.status() : "no_resp"}`);
      return null;
    }
    const buffer = await resp.body();
    fs.writeFileSync(filepath, buffer);
    // return the relative path the dashboard can serve: /avatars/<filename>
    return `/avatars/${filename}`;
  } catch (err) {
    console.warn("[avatar] error downloading avatar:", err);
    return null;
  }
}

// ---------- seed writer ----------
const SEED_PATH = path.join(process.cwd(), "prisma", "seed.ts");
if (!fs.existsSync(SEED_PATH)) {
  fs.writeFileSync(SEED_PATH, `// Auto-generated by scraper\nexport const influencers = [\n`, "utf8");
}
function appendToSeed(obj: any) {
  const line = "  " + JSON.stringify(obj, (_k, v) => (v === undefined ? null : v), 2) + ",\n";
  fs.appendFileSync(SEED_PATH, line, "utf8");
}
function finalizeSeedFile() {
  fs.appendFileSync(SEED_PATH, `];\n`, "utf8");
}

// ---------- SIGI_STATE helper ----------
function extractSigiState(html: string): any | null {
  const reIdScript = /<script[^>]*id=["']SIGI_STATE["'][^>]*>([\s\S]*?)<\/script>/i;
  let m = html.match(reIdScript);
  if (m) {
    try { return JSON.parse(m[1]); } catch {}
  }
  const reWindow = /window\[['"]SIGI_STATE['"]\]\s*=\s*({[\s\S]*?});/;
  m = html.match(reWindow);
  if (m) {
    try { return JSON.parse(m[1]); } catch {}
  }
  return null;
}

// ---------- video stat extractor (fallback) ----------
function extractVideoStatsFromHtml(html: string) {
  let play = 0, like = 0, comment = 0, share = 0, followers = 0;

  const statsRegex = /"stats"\s*:\s*({[\s\S]*?})/;
  const sMatch = html.match(statsRegex);
  if (sMatch) {
    try {
      const statsObj = JSON.parse(sMatch[1]);
      play = parseCount(statsObj.playCount ?? statsObj.play_count ?? statsObj.plays ?? 0);
      like = parseCount(statsObj.diggCount ?? statsObj.digg_count ?? statsObj.likeCount ?? 0);
      comment = parseCount(statsObj.commentCount ?? statsObj.comment_count ?? 0);
      share = parseCount(statsObj.shareCount ?? statsObj.share_count ?? 0);
    } catch {}
  }

  const authRegex = /"authorStats"\s*:\s*({[\s\S]*?})/;
  const aMatch = html.match(authRegex);
  if (aMatch) {
    try {
      const aobj = JSON.parse(aMatch[1]);
      followers = parseCount(aobj.followerCount ?? aobj.follower_count ?? aobj.followers ?? 0);
    } catch {}
  }

  if (!play) {
    const p = html.match(/"playCount"\s*:\s*([0-9,.KMkm]+)/);
    if (p) play = parseCount(p[1]);
  }
  if (!like) {
    const l = html.match(/"diggCount"\s*:\s*([0-9,.KMkm]+)/) || html.match(/"likeCount"\s*:\s*([0-9,.KMkm]+)/);
    if (l) like = parseCount(l[1]);
  }
  if (!comment) {
    const c = html.match(/"commentCount"\s*:\s*([0-9,.KMkm]+)/);
    if (c) comment = parseCount(c[1]);
  }
  if (!share) {
    const s = html.match(/"shareCount"\s*:\s*([0-9,.KMkm]+)/);
    if (s) share = parseCount(s[1]);
  }

  // textual fallback
  if (!play) {
    const tv = html.replace(/\s+/g, " ").match(/([0-9,.KMkm]+)\s*views/i);
    if (tv) play = parseCount(tv[1]);
  }
  if (!like) {
    const tl = html.replace(/\s+/g, " ").match(/([0-9,.KMkm]+)\s*likes/i);
    if (tl) like = parseCount(tl[1]);
  }

  return { play, like, comment, share, followers };
}

// ---------- pinned detection ----------
function getPinnedIdsFromProfileHtml(html: string): Set<string> {
  const pinned = new Set<string>();

  // 1) badge div detection
  const badgeRe = /<div[^>]*data-e2e=["']video-card-badge["'][^>]*>([\s\S]*?)<\/div>/gi;
  let bm;
  while ((bm = badgeRe.exec(html)) !== null) {
    const idx = bm.index;
    const start = Math.max(0, idx - 1500);
    const end = Math.min(html.length, idx + 1500);
    const window = html.slice(start, end);

    const anchorMatch = window.match(/\/@[\w.-]+\/video\/(\d+)/i);
    if (anchorMatch) pinned.add(anchorMatch[1]);
    else {
      const idMatch = window.match(/"id"\s*:\s*"?(\d{6,})"?/);
      if (idMatch) pinned.add(idMatch[1]);
    }
  }

  // 2) anchors with pinned badge nearby
  const anchorWithPinnedRe = /\/@[\w.-]+\/video\/(\d+)[\s\S]{0,200}?<div[^>]*data-e2e=["']video-card-badge["'][^>]*>[\s\S]*?Pinned/i;
  let am;
  while ((am = anchorWithPinnedRe.exec(html)) !== null) {
    pinned.add(am[1]);
  }

  // 3) enable_profile_pinned_video heuristic
  const enableRe = /"enable_profile_pinned_video"\s*:\s*\{([\s\S]*?)\}/i;
  const eMatch = html.match(enableRe);
  if (eMatch) {
    const area = eMatch[1];
    const numIds = area.match(/\d{6,}/g);
    if (numIds) numIds.forEach((id) => pinned.add(id));
    const objEnd = eMatch.index ?? 0;
    const after = html.slice((objEnd + eMatch[0].length), (objEnd + eMatch[0].length + 500));
    const afterIds = after.match(/\d{6,}/g);
    if (afterIds) afterIds.forEach((id) => pinned.add(id));
  }

  return pinned;
}

// ---------- browser helpers ----------
async function openPersistentContext(): Promise<BrowserContext> {
  const userDataDir = path.join(process.cwd(), "tiktokUserData");
  if (!fs.existsSync(userDataDir)) fs.mkdirSync(userDataDir, { recursive: true });

  const context = await chromium.launchPersistentContext(userDataDir, {
    headless: HEADLESS,
    userAgent: USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)],
  });

  await context.route("**/*", (route) => {
    const url = route.request().url();
    const block = [".css", "google-analytics", "analytics", "font", "doubleclick"]; // keep images allowed
    if (block.some((b) => url.includes(b))) route.abort();
    else route.continue();
  });

  return context;
}

async function getHandlesFromHashtag(page: any, hashtag: string, maxVideos = 60) {
  const url = `https://www.tiktok.com/tag/${encodeURIComponent(hashtag)}`;
  await page.goto(url, { timeout: 50000 });
  await page.waitForTimeout(5000);

  const captcha = await page.$("iframe[src*='captcha'], .captcha-container");
  if (captcha) {
    console.log("âš ï¸ Captcha detectado. ResuÃ©lvelo manualmente.");
    await page.waitForFunction(() => !document.querySelector("iframe[src*='captcha'], .captcha-container"), { timeout: 0 });
    console.log("âœ… Captcha resuelto, continuando...");
  }

  const html = await page.content();
  try { fs.writeFileSync(path.join(process.cwd(), "debug.html"), html, "utf-8"); } catch {}

  const regex = /\/@([\w.-]+)/g;
  const handlesSet = new Set<string>();
  let match;
  while ((match = regex.exec(html)) !== null) {
    handlesSet.add(match[1]);
    if (handlesSet.size >= maxVideos) break;
  }

  console.log(`Found ${handlesSet.size} handles for hashtag ${hashtag}`);
  return Array.from(handlesSet);
}

// ---------- scrapeProfile ----------
async function scrapeProfile(context: BrowserContext, handle: string, niche?: string) {
  const page = await context.newPage();
  try {
    const url = `https://www.tiktok.com/@${handle}`;
    await page.goto(url, { waitUntil: "domcontentloaded", timeout: 40000 });
    await page.waitForTimeout(3000);

    let html = await page.content();
    try { fs.writeFileSync(path.join(process.cwd(), `debug_profile_${handle}.html`), html, "utf8"); } catch {}

    const sigi = extractSigiState(html);

    // user fields
    let followers = 0;
    let avatarUrl: string | null = null;
    let bio = "";

    if (sigi) {
      const userObj =
        (sigi.UserModule && sigi.UserModule.users && sigi.UserModule.users[handle]) ||
        (sigi.UserModule && sigi.UserModule[handle]) ||
        null;
      if (userObj) {
        followers = Number(userObj.followerCount ?? userObj.follower_count ?? followers) || followers;
        const candidate = userObj.avatarLarger || userObj.avatar || userObj.avatar_medium || userObj.avatarThumb || null;
        if (candidate) avatarUrl = cleanAvatarUrlKeepQuery(candidate);
        bio = (userObj.signature ?? userObj.description ?? bio) || "";
      }
    }

    // fallback followers / avatar / bio from HTML
    if (!followers) {
      const fMatch = html.match(/"followerCount"\s*:\s*([0-9,.KMkm]+)/);
      if (fMatch) followers = parseCount(fMatch[1]);
    }
    if (!avatarUrl) {
      const metaImg = html.match(/<meta[^>]*property=["']og:image["'][^>]*content=["']([^"']+)["']/i);
      if (metaImg) avatarUrl = cleanAvatarUrlKeepQuery(metaImg[1]);
    }
    if (!bio) {
      const bioMatch = html.match(/"signature"\s*:\s*"(.*?)"/);
      if (bioMatch) bio = bioMatch[1].replace(/\\"/g, '"');
    }

    // immediate follower filter
    if (!(FOLLOWERS_MIN <= followers && followers <= FOLLOWERS_MAX)) {
      console.log(`[${handle}] âŒ Skip (followers=${followers})`);
      await page.close();
      return null;
    }

    // Attempt to download avatar and cache locally (preferred)
    let finalAvatarUrl: string | null = null;
    if (avatarUrl) {
      const downloaded = await downloadAndCacheAvatar(context, avatarUrl, handle);
      if (downloaded) {
        finalAvatarUrl = downloaded; // local path served by app: /avatars/<file>
        console.log(`[${handle}] avatar cached -> ${downloaded}`);
      } else {
        // fallback: keep remote (decoded) url so dashboard can try to load it
        finalAvatarUrl = avatarUrl;
        console.log(`[${handle}] avatar download failed, keeping remote url`);
      }
    }

    // pinned detection
    const pinnedIds = getPinnedIdsFromProfileHtml(html);
    if (pinnedIds.size > 0) console.log(`[${handle}] pinnedIds detected:`, Array.from(pinnedIds));

    // collect non-pinned video ids (anchors + scrolling)
    const collected = new Set<string>();
    const collectFromHtml = (h: string) => {
      const anchorRegex = /\/@[\w.-]+\/video\/(\d+)/g;
      let aMatch;
      while ((aMatch = anchorRegex.exec(h)) !== null && collected.size < MAX_VIDEOS_PER_PROFILE) {
        const id = aMatch[1];
        if (!pinnedIds.has(id)) collected.add(id);
      }
    };

    collectFromHtml(html);
    const MAX_SCROLLS = 8;
    let scrolls = 0;
    while (collected.size < MAX_VIDEOS_PER_PROFILE && scrolls < MAX_SCROLLS) {
      scrolls++;
      try { await page.evaluate(() => window.scrollBy(0, window.innerHeight * 1.3)); } catch {}
      await page.waitForTimeout(1400 + Math.floor(Math.random() * 1000));
      html = await page.content();
      try { fs.writeFileSync(path.join(process.cwd(), `debug_profile_${handle}_scroll${scrolls}.html`), html, "utf8"); } catch {}
      const morePinned = getPinnedIdsFromProfileHtml(html);
      morePinned.forEach((id) => pinnedIds.add(id));
      collectFromHtml(html);
    }

    const videoIds = Array.from(collected).slice(0, MAX_VIDEOS_PER_PROFILE);
    console.log(`[${handle}] videoIds found:`, videoIds);

    // if no non-pinned videos
    if (videoIds.length === 0) {
      await page.close();
      console.log(`[${handle}] NO non-pinned videos found`);
      return {
        handle,
        profileUrl: url,
        followers,
        avatarUrl: finalAvatarUrl,
        niche: niche || null,
        avgViews: 0,
        engagementRate: 0,
        bio,
        language: bio ? (typeof franc === "function" ? franc(bio) : "und") : "und",
        lastScrapedAt: new Date().toISOString(),
      };
    }

    // open videos and extract stats
    const plays: number[] = [];
    let totalLikes = 0, totalComments = 0, totalShares = 0;
    for (let i = 0; i < Math.min(videoIds.length, MAX_VIDEOS_PER_PROFILE); i++) {
      const vidId = videoIds[i];
      const vidUrl = `https://www.tiktok.com/@${handle}/video/${vidId}`;
      try {
        const vpage = await context.newPage();
        await vpage.goto(vidUrl, { waitUntil: "domcontentloaded", timeout: 35000 });
        await vpage.waitForTimeout(2200 + Math.floor(Math.random() * 800));

        const vhtml = await vpage.content();
        if (i < 2) {
          try { fs.writeFileSync(path.join(process.cwd(), `debug_video_${handle}_${vidId}.html`), vhtml, "utf8"); } catch {}
        }

        const vsigi = extractSigiState(vhtml);
        let play = 0, like = 0, comment = 0, share = 0, vidFollowers = 0;

        if (vsigi && vsigi.ItemModule && vsigi.ItemModule[vidId]) {
          const it = vsigi.ItemModule[vidId];
          play = parseCount(it.stats?.playCount ?? it.playCount ?? it.play_count ?? it.video?.playCount ?? 0);
          like = parseCount(it.stats?.diggCount ?? it.diggCount ?? it.stats?.likeCount ?? 0);
          comment = parseCount(it.stats?.commentCount ?? it.commentCount ?? 0);
          share = parseCount(it.stats?.shareCount ?? it.shareCount ?? 0);
        } else {
          const parsed = extractVideoStatsFromHtml(vhtml);
          play = parsed.play;
          like = parsed.like;
          comment = parsed.comment;
          share = parsed.share;
          vidFollowers = parsed.followers || 0;
        }

        if (vidFollowers && vidFollowers > followers) followers = vidFollowers;
        if (play > 0) plays.push(play);
        totalLikes += like;
        totalComments += comment;
        totalShares += share;

        await vpage.close();
        await sleep(400 + Math.floor(Math.random() * 400));
      } catch (err) {
        console.warn(`[${handle}] video ${vidId} -> error reading:`, err);
        try { const pages = context.pages(); if (pages.length) await pages[pages.length - 1].close(); } catch {}
      }
    }

    // metrics: engagementRate (%) = ((likes+comments+shares)/n_videos / followers) * 100
    let avgViews = 0;
    let engagementRate = 0;
    const nVideos = plays.length;
    if (nVideos > 0) {
      avgViews = Math.round(plays.reduce((a, b) => a + b, 0) / nVideos);
      const totalEng = totalLikes + totalComments + totalShares;
      if (followers > 0) {
        const perPostEng = totalEng / nVideos;
        engagementRate = Number(((perPostEng / followers) * 100).toFixed(2));
      }
    }

    let language = "und";
    try { if (bio && typeof franc === "function") language = franc(bio) || "und"; } catch {}

    await page.close();

    return {
      handle,
      profileUrl: url,
      followers,
      avatarUrl: finalAvatarUrl || null,
      niche: niche || null,
      avgViews,
      engagementRate,
      bio,
      language,
      lastScrapedAt: new Date().toISOString(),
    };
  } catch (err) {
    console.error("âŒ Error scraping profile", handle, err);
    try { await page.close(); } catch {}
    return null;
  }
}

// ---------- main pipeline ----------
async function runForHashtags(hashtags: string[]) {
  const context = await openPersistentContext();
  const page = await context.newPage();

  console.log("âš ï¸ Si aparece un CAPTCHA, resuÃ©lvelo manualmente en la ventana abierta.");
  console.log("Cuando termines, presiona Enter para continuar...");
  await new Promise((resolve) => process.stdin.once("data", resolve));

  const discovered = new Map<string, string>();
  for (const tag of hashtags) {
    console.log("Discovering handles for", tag);
    const handles = await getHandlesFromHashtag(page, tag, 150);
    handles.forEach((h) => discovered.set(h, tag));
    await sleep(API_DELAY_MS);
  }

  console.log("Total discovered handles:", discovered.size);

  const handlesArr = Array.from(discovered.entries());
  for (let i = 0; i < handlesArr.length; i += MAX_CONCURRENCY) {
    const slice = handlesArr.slice(i, i + MAX_CONCURRENCY);
    for (const [handle, niche] of slice) {
      await sleep(API_DELAY_MS);
      const profile = await scrapeProfile(context, handle, niche);
      if (!profile) continue;
      appendToSeed(profile);
      console.log("âœ… Saved:", profile.handle, "followers", profile.followers, "ER", profile.engagementRate + "%");
    }
  }

  await page.close();
  await context.close();
  finalizeSeedFile();
}

// Entry
(async () => {
  const tagsStr = process.env.TAGS || "marketing,fitness,food";
  const tags = tagsStr.split(",").map((t) => t.trim()).filter(Boolean);
  await runForHashtags(tags);
  console.log("ðŸŽ‰ Done. Data appended to prisma/seed.ts");
})();
